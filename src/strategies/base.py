import traceback
import pandas as pd
from abc import ABC, abstractmethod
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)

class BaseStrategy(ABC):
    """
    Abstract Base Class for all trading strategies.

    Defines the common interface that all strategies must implement.
    Requires subclasses to implement the `generate_signals` method.
    """

    def __init__(self, tickers: List[str]):
        """
        Initializes the base strategy.

        Args:
            tickers (List[str]): A list of ticker symbols that this strategy
                                 might potentially operate on. This is mainly
                                 for informational purposes or if the strategy
                                 needs context about the broader universe.
        """
        if not isinstance(tickers, list) or not all(isinstance(t, str) for t in tickers):
            raise TypeError("BaseStrategy requires 'tickers' to be a list of strings.")

        self.tickers = tickers
        # Można dodać inicjalizację wspólnych atrybutów, np. loggera
        # self.logger = logging.getLogger(self.__class__.__name__)
        logger.debug(f"BaseStrategy initialized for {self.__class__.__name__} with tickers: {tickers}")


    @abstractmethod
    def generate_signals(self, ticker: str, data: pd.DataFrame) -> Optional[pd.DataFrame]:
        """
        Generate trading signals for a single ticker based on its historical data.

        This method must be implemented by all concrete strategy subclasses.

        Args:
            ticker (str): The ticker symbol for which signals are being generated.
            data (pd.DataFrame): A DataFrame containing the historical OHLCV data
                                 for the specified ticker. It should have a
                                 DatetimeIndex.

        Returns:
            Optional[pd.DataFrame]: A DataFrame with the same DatetimeIndex as the input `data`.
                                    It must contain at least a 'Signal' column, where:
                                      - 1 indicates a buy signal.
                                      - -1 indicates a sell (or short) signal.
                                      - 0 indicates no action or hold.
                                    Optionally, it can include a 'Position' column indicating the
                                    desired position state (1 for long, -1 for short, 0 for flat)
                                    and any intermediate calculation columns (like SMA, RSI, etc.)
                                    which might be useful for analysis or debugging.
                                    Returns None if signals cannot be generated (e.g., due to
                                    insufficient data).
        """
        pass


    def run_strategy_on_all(self, data_dict: dict[str, pd.DataFrame]) -> dict[str, Optional[pd.DataFrame]]:
        """
        Applies the generate_signals method to all tickers provided in data_dict.

        This is a convenience method. The core backtesting loop might call
        `generate_signals` directly or use pre-computed signals.

        Args:
            data_dict (dict[str, pd.DataFrame]): A dictionary where keys are ticker symbols
                                                 and values are DataFrames with their
                                                 historical data.

        Returns:
            dict[str, Optional[pd.DataFrame]]: A dictionary where keys are ticker symbols and
                                               values are the DataFrames containing signals
                                               generated by `generate_signals`, or None if
                                               signals couldn't be generated for a ticker.
        """
        all_signals = {}
        for ticker in self.tickers: # Iterate through tickers the strategy was initialized with
            if ticker in data_dict:
                ticker_data = data_dict[ticker]
                if ticker_data is not None and not ticker_data.empty:
                    try:
                        signals_df = self.generate_signals(ticker, ticker_data)
                        all_signals[ticker] = signals_df # Store DataFrame or None
                        if signals_df is None:
                             logger.info(f"Strategy {self.__class__.__name__}: No signals generated for {ticker} (returned None).")
                    except Exception as e:
                        logger.error(f"Strategy {self.__class__.__name__}: Error generating signals for {ticker}: {e}")
                        logger.error(traceback.format_exc())
                        all_signals[ticker] = None # Indicate error for this ticker
                else:
                    logger.warning(f"Strategy {self.__class__.__name__}: No data provided for ticker {ticker}.")
                    all_signals[ticker] = None
            else:
                 logger.warning(f"Strategy {self.__class__.__name__}: Ticker {ticker} not found in provided data_dict.")
                 all_signals[ticker] = None

        return all_signals