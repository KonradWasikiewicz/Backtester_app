import dash
from dash import Dash, Input, Output, State, ctx
import logging
import time
from src.ui.ids.ids import WizardIDs, SharedComponentIDs, StrategyConfigIDs

# Configure logging
logger = logging.getLogger(__name__)

def register_run_backtest_callback(app: Dash):
    """
    Register the callback that connects the Run Backtest button in the wizard
    to the backtest trigger store.
    """
    logger.info("Registering Run Backtest button callback...")
    
    @app.callback(
        Output(SharedComponentIDs.RUN_BACKTEST_TRIGGER_STORE, 'data'),
        Input(WizardIDs.RUN_BACKTEST_BUTTON_WIZARD, 'n_clicks'),
        State(StrategyConfigIDs.STRATEGY_CONFIG_STORE_MAIN, 'data'),
        prevent_initial_call=True
    )
    def on_run_backtest_button_clicked(n_clicks, config_data):
        """
        When the Run Backtest button is clicked, trigger the backtest by updating
        the RUN_BACKTEST_TRIGGER_STORE with the current timestamp.
        """
        if not n_clicks:
            return dash.no_update
        
        if not config_data:
            logger.warning("Run Backtest button clicked but config_data is None. This will cause the backtest to fail.")
        else:
            # Check for required fields
            required_fields = ["strategy_type", "tickers", "start_date", "end_date", "initial_capital"]
            missing_fields = [field for field in required_fields if field not in config_data or not config_data[field]]
            
            if missing_fields:
                logger.warning(f"Run Backtest button clicked but config_data is missing required fields: {missing_fields}")
            else:
                logger.info(f"Run Backtest button clicked. Config validated successfully.")
        
        # Return a trigger value (timestamp) that the backtest callback listens for
        return {"timestamp": time.time(), "source": "wizard"}
